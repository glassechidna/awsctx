// Code generated by internal/generate/main.go. DO NOT EDIT.

package managedblockchainctx

import (
	"context"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/service/managedblockchain"
	"github.com/aws/aws-sdk-go/service/managedblockchain/managedblockchainiface"
	"github.com/glassechidna/awsctx"
)

type ManagedBlockchain interface {
	CreateMemberWithContext(ctx context.Context, input *managedblockchain.CreateMemberInput, opts ...request.Option) (*managedblockchain.CreateMemberOutput, error)
	CreateNetworkWithContext(ctx context.Context, input *managedblockchain.CreateNetworkInput, opts ...request.Option) (*managedblockchain.CreateNetworkOutput, error)
	CreateNodeWithContext(ctx context.Context, input *managedblockchain.CreateNodeInput, opts ...request.Option) (*managedblockchain.CreateNodeOutput, error)
	CreateProposalWithContext(ctx context.Context, input *managedblockchain.CreateProposalInput, opts ...request.Option) (*managedblockchain.CreateProposalOutput, error)
	DeleteMemberWithContext(ctx context.Context, input *managedblockchain.DeleteMemberInput, opts ...request.Option) (*managedblockchain.DeleteMemberOutput, error)
	DeleteNodeWithContext(ctx context.Context, input *managedblockchain.DeleteNodeInput, opts ...request.Option) (*managedblockchain.DeleteNodeOutput, error)
	GetMemberWithContext(ctx context.Context, input *managedblockchain.GetMemberInput, opts ...request.Option) (*managedblockchain.GetMemberOutput, error)
	GetNetworkWithContext(ctx context.Context, input *managedblockchain.GetNetworkInput, opts ...request.Option) (*managedblockchain.GetNetworkOutput, error)
	GetNodeWithContext(ctx context.Context, input *managedblockchain.GetNodeInput, opts ...request.Option) (*managedblockchain.GetNodeOutput, error)
	GetProposalWithContext(ctx context.Context, input *managedblockchain.GetProposalInput, opts ...request.Option) (*managedblockchain.GetProposalOutput, error)
	ListInvitationsWithContext(ctx context.Context, input *managedblockchain.ListInvitationsInput, opts ...request.Option) (*managedblockchain.ListInvitationsOutput, error)
	ListMembersWithContext(ctx context.Context, input *managedblockchain.ListMembersInput, opts ...request.Option) (*managedblockchain.ListMembersOutput, error)
	ListNetworksWithContext(ctx context.Context, input *managedblockchain.ListNetworksInput, opts ...request.Option) (*managedblockchain.ListNetworksOutput, error)
	ListNodesWithContext(ctx context.Context, input *managedblockchain.ListNodesInput, opts ...request.Option) (*managedblockchain.ListNodesOutput, error)
	ListProposalVotesWithContext(ctx context.Context, input *managedblockchain.ListProposalVotesInput, opts ...request.Option) (*managedblockchain.ListProposalVotesOutput, error)
	ListProposalsWithContext(ctx context.Context, input *managedblockchain.ListProposalsInput, opts ...request.Option) (*managedblockchain.ListProposalsOutput, error)
	RejectInvitationWithContext(ctx context.Context, input *managedblockchain.RejectInvitationInput, opts ...request.Option) (*managedblockchain.RejectInvitationOutput, error)
	VoteOnProposalWithContext(ctx context.Context, input *managedblockchain.VoteOnProposalInput, opts ...request.Option) (*managedblockchain.VoteOnProposalOutput, error)
}

type Client struct {
	managedblockchainiface.ManagedBlockchainAPI
	Contexter awsctx.Contexter
}

func New(base managedblockchainiface.ManagedBlockchainAPI, ctxer awsctx.Contexter) ManagedBlockchain {
	return &Client{
		ManagedBlockchainAPI: base,
		Contexter: ctxer,
	}
}

var _ ManagedBlockchain = (*managedblockchain.ManagedBlockchain)(nil)
var _ ManagedBlockchain = (*Client)(nil)

func (c *Client) CreateMemberWithContext(ctx context.Context, input *managedblockchain.CreateMemberInput, opts ...request.Option) (*managedblockchain.CreateMemberOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "CreateMember",
		Input:   input,
		Output:  (*managedblockchain.CreateMemberOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.CreateMemberWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.CreateMemberOutput), req.Error
}

func (c *Client) CreateNetworkWithContext(ctx context.Context, input *managedblockchain.CreateNetworkInput, opts ...request.Option) (*managedblockchain.CreateNetworkOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "CreateNetwork",
		Input:   input,
		Output:  (*managedblockchain.CreateNetworkOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.CreateNetworkWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.CreateNetworkOutput), req.Error
}

func (c *Client) CreateNodeWithContext(ctx context.Context, input *managedblockchain.CreateNodeInput, opts ...request.Option) (*managedblockchain.CreateNodeOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "CreateNode",
		Input:   input,
		Output:  (*managedblockchain.CreateNodeOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.CreateNodeWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.CreateNodeOutput), req.Error
}

func (c *Client) CreateProposalWithContext(ctx context.Context, input *managedblockchain.CreateProposalInput, opts ...request.Option) (*managedblockchain.CreateProposalOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "CreateProposal",
		Input:   input,
		Output:  (*managedblockchain.CreateProposalOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.CreateProposalWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.CreateProposalOutput), req.Error
}

func (c *Client) DeleteMemberWithContext(ctx context.Context, input *managedblockchain.DeleteMemberInput, opts ...request.Option) (*managedblockchain.DeleteMemberOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "DeleteMember",
		Input:   input,
		Output:  (*managedblockchain.DeleteMemberOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.DeleteMemberWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.DeleteMemberOutput), req.Error
}

func (c *Client) DeleteNodeWithContext(ctx context.Context, input *managedblockchain.DeleteNodeInput, opts ...request.Option) (*managedblockchain.DeleteNodeOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "DeleteNode",
		Input:   input,
		Output:  (*managedblockchain.DeleteNodeOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.DeleteNodeWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.DeleteNodeOutput), req.Error
}

func (c *Client) GetMemberWithContext(ctx context.Context, input *managedblockchain.GetMemberInput, opts ...request.Option) (*managedblockchain.GetMemberOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "GetMember",
		Input:   input,
		Output:  (*managedblockchain.GetMemberOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.GetMemberWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.GetMemberOutput), req.Error
}

func (c *Client) GetNetworkWithContext(ctx context.Context, input *managedblockchain.GetNetworkInput, opts ...request.Option) (*managedblockchain.GetNetworkOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "GetNetwork",
		Input:   input,
		Output:  (*managedblockchain.GetNetworkOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.GetNetworkWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.GetNetworkOutput), req.Error
}

func (c *Client) GetNodeWithContext(ctx context.Context, input *managedblockchain.GetNodeInput, opts ...request.Option) (*managedblockchain.GetNodeOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "GetNode",
		Input:   input,
		Output:  (*managedblockchain.GetNodeOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.GetNodeWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.GetNodeOutput), req.Error
}

func (c *Client) GetProposalWithContext(ctx context.Context, input *managedblockchain.GetProposalInput, opts ...request.Option) (*managedblockchain.GetProposalOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "GetProposal",
		Input:   input,
		Output:  (*managedblockchain.GetProposalOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.GetProposalWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.GetProposalOutput), req.Error
}

func (c *Client) ListInvitationsWithContext(ctx context.Context, input *managedblockchain.ListInvitationsInput, opts ...request.Option) (*managedblockchain.ListInvitationsOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListInvitations",
		Input:   input,
		Output:  (*managedblockchain.ListInvitationsOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListInvitationsWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListInvitationsOutput), req.Error
}

func (c *Client) ListMembersWithContext(ctx context.Context, input *managedblockchain.ListMembersInput, opts ...request.Option) (*managedblockchain.ListMembersOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListMembers",
		Input:   input,
		Output:  (*managedblockchain.ListMembersOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListMembersWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListMembersOutput), req.Error
}

func (c *Client) ListNetworksWithContext(ctx context.Context, input *managedblockchain.ListNetworksInput, opts ...request.Option) (*managedblockchain.ListNetworksOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListNetworks",
		Input:   input,
		Output:  (*managedblockchain.ListNetworksOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListNetworksWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListNetworksOutput), req.Error
}

func (c *Client) ListNodesWithContext(ctx context.Context, input *managedblockchain.ListNodesInput, opts ...request.Option) (*managedblockchain.ListNodesOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListNodes",
		Input:   input,
		Output:  (*managedblockchain.ListNodesOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListNodesWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListNodesOutput), req.Error
}

func (c *Client) ListProposalVotesWithContext(ctx context.Context, input *managedblockchain.ListProposalVotesInput, opts ...request.Option) (*managedblockchain.ListProposalVotesOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListProposalVotes",
		Input:   input,
		Output:  (*managedblockchain.ListProposalVotesOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListProposalVotesWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListProposalVotesOutput), req.Error
}

func (c *Client) ListProposalsWithContext(ctx context.Context, input *managedblockchain.ListProposalsInput, opts ...request.Option) (*managedblockchain.ListProposalsOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListProposals",
		Input:   input,
		Output:  (*managedblockchain.ListProposalsOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListProposalsWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListProposalsOutput), req.Error
}

func (c *Client) RejectInvitationWithContext(ctx context.Context, input *managedblockchain.RejectInvitationInput, opts ...request.Option) (*managedblockchain.RejectInvitationOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "RejectInvitation",
		Input:   input,
		Output:  (*managedblockchain.RejectInvitationOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.RejectInvitationWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.RejectInvitationOutput), req.Error
}

func (c *Client) VoteOnProposalWithContext(ctx context.Context, input *managedblockchain.VoteOnProposalInput, opts ...request.Option) (*managedblockchain.VoteOnProposalOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "VoteOnProposal",
		Input:   input,
		Output:  (*managedblockchain.VoteOnProposalOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.VoteOnProposalWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.VoteOnProposalOutput), req.Error
}
