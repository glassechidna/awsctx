// Code generated by internal/generate/main.go. DO NOT EDIT.

package managedblockchainctx

import (
	"context"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/service/managedblockchain"
	"github.com/aws/aws-sdk-go/service/managedblockchain/managedblockchainiface"
	"github.com/glassechidna/awsctx"
)

type ManagedBlockchain interface {
	CreateAccessorWithContext(ctx context.Context, input *managedblockchain.CreateAccessorInput, opts ...request.Option) (*managedblockchain.CreateAccessorOutput, error)
	CreateMemberWithContext(ctx context.Context, input *managedblockchain.CreateMemberInput, opts ...request.Option) (*managedblockchain.CreateMemberOutput, error)
	CreateNetworkWithContext(ctx context.Context, input *managedblockchain.CreateNetworkInput, opts ...request.Option) (*managedblockchain.CreateNetworkOutput, error)
	CreateNodeWithContext(ctx context.Context, input *managedblockchain.CreateNodeInput, opts ...request.Option) (*managedblockchain.CreateNodeOutput, error)
	CreateProposalWithContext(ctx context.Context, input *managedblockchain.CreateProposalInput, opts ...request.Option) (*managedblockchain.CreateProposalOutput, error)
	DeleteAccessorWithContext(ctx context.Context, input *managedblockchain.DeleteAccessorInput, opts ...request.Option) (*managedblockchain.DeleteAccessorOutput, error)
	DeleteMemberWithContext(ctx context.Context, input *managedblockchain.DeleteMemberInput, opts ...request.Option) (*managedblockchain.DeleteMemberOutput, error)
	DeleteNodeWithContext(ctx context.Context, input *managedblockchain.DeleteNodeInput, opts ...request.Option) (*managedblockchain.DeleteNodeOutput, error)
	GetAccessorWithContext(ctx context.Context, input *managedblockchain.GetAccessorInput, opts ...request.Option) (*managedblockchain.GetAccessorOutput, error)
	GetMemberWithContext(ctx context.Context, input *managedblockchain.GetMemberInput, opts ...request.Option) (*managedblockchain.GetMemberOutput, error)
	GetNetworkWithContext(ctx context.Context, input *managedblockchain.GetNetworkInput, opts ...request.Option) (*managedblockchain.GetNetworkOutput, error)
	GetNodeWithContext(ctx context.Context, input *managedblockchain.GetNodeInput, opts ...request.Option) (*managedblockchain.GetNodeOutput, error)
	GetProposalWithContext(ctx context.Context, input *managedblockchain.GetProposalInput, opts ...request.Option) (*managedblockchain.GetProposalOutput, error)
	ListAccessorsWithContext(ctx context.Context, input *managedblockchain.ListAccessorsInput, opts ...request.Option) (*managedblockchain.ListAccessorsOutput, error)
	ListAccessorsPagesWithContext(ctx context.Context, input *managedblockchain.ListAccessorsInput, cb func(*managedblockchain.ListAccessorsOutput, bool) bool, opts ...request.Option) error
	ListInvitationsWithContext(ctx context.Context, input *managedblockchain.ListInvitationsInput, opts ...request.Option) (*managedblockchain.ListInvitationsOutput, error)
	ListInvitationsPagesWithContext(ctx context.Context, input *managedblockchain.ListInvitationsInput, cb func(*managedblockchain.ListInvitationsOutput, bool) bool, opts ...request.Option) error
	ListMembersWithContext(ctx context.Context, input *managedblockchain.ListMembersInput, opts ...request.Option) (*managedblockchain.ListMembersOutput, error)
	ListMembersPagesWithContext(ctx context.Context, input *managedblockchain.ListMembersInput, cb func(*managedblockchain.ListMembersOutput, bool) bool, opts ...request.Option) error
	ListNetworksWithContext(ctx context.Context, input *managedblockchain.ListNetworksInput, opts ...request.Option) (*managedblockchain.ListNetworksOutput, error)
	ListNetworksPagesWithContext(ctx context.Context, input *managedblockchain.ListNetworksInput, cb func(*managedblockchain.ListNetworksOutput, bool) bool, opts ...request.Option) error
	ListNodesWithContext(ctx context.Context, input *managedblockchain.ListNodesInput, opts ...request.Option) (*managedblockchain.ListNodesOutput, error)
	ListNodesPagesWithContext(ctx context.Context, input *managedblockchain.ListNodesInput, cb func(*managedblockchain.ListNodesOutput, bool) bool, opts ...request.Option) error
	ListProposalVotesWithContext(ctx context.Context, input *managedblockchain.ListProposalVotesInput, opts ...request.Option) (*managedblockchain.ListProposalVotesOutput, error)
	ListProposalVotesPagesWithContext(ctx context.Context, input *managedblockchain.ListProposalVotesInput, cb func(*managedblockchain.ListProposalVotesOutput, bool) bool, opts ...request.Option) error
	ListProposalsWithContext(ctx context.Context, input *managedblockchain.ListProposalsInput, opts ...request.Option) (*managedblockchain.ListProposalsOutput, error)
	ListProposalsPagesWithContext(ctx context.Context, input *managedblockchain.ListProposalsInput, cb func(*managedblockchain.ListProposalsOutput, bool) bool, opts ...request.Option) error
	ListTagsForResourceWithContext(ctx context.Context, input *managedblockchain.ListTagsForResourceInput, opts ...request.Option) (*managedblockchain.ListTagsForResourceOutput, error)
	RejectInvitationWithContext(ctx context.Context, input *managedblockchain.RejectInvitationInput, opts ...request.Option) (*managedblockchain.RejectInvitationOutput, error)
	TagResourceWithContext(ctx context.Context, input *managedblockchain.TagResourceInput, opts ...request.Option) (*managedblockchain.TagResourceOutput, error)
	UntagResourceWithContext(ctx context.Context, input *managedblockchain.UntagResourceInput, opts ...request.Option) (*managedblockchain.UntagResourceOutput, error)
	UpdateMemberWithContext(ctx context.Context, input *managedblockchain.UpdateMemberInput, opts ...request.Option) (*managedblockchain.UpdateMemberOutput, error)
	UpdateNodeWithContext(ctx context.Context, input *managedblockchain.UpdateNodeInput, opts ...request.Option) (*managedblockchain.UpdateNodeOutput, error)
	VoteOnProposalWithContext(ctx context.Context, input *managedblockchain.VoteOnProposalInput, opts ...request.Option) (*managedblockchain.VoteOnProposalOutput, error)
}

type Client struct {
	managedblockchainiface.ManagedBlockchainAPI
	Contexter awsctx.Contexter
}

func New(base managedblockchainiface.ManagedBlockchainAPI, ctxer awsctx.Contexter) ManagedBlockchain {
	return &Client{
		ManagedBlockchainAPI: base,
		Contexter: ctxer,
	}
}

var _ ManagedBlockchain = (*managedblockchain.ManagedBlockchain)(nil)
var _ ManagedBlockchain = (*Client)(nil)

func (c *Client) CreateAccessorWithContext(ctx context.Context, input *managedblockchain.CreateAccessorInput, opts ...request.Option) (*managedblockchain.CreateAccessorOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "CreateAccessor",
		Input:   input,
		Output:  (*managedblockchain.CreateAccessorOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.CreateAccessorWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.CreateAccessorOutput), req.Error
}

func (c *Client) CreateMemberWithContext(ctx context.Context, input *managedblockchain.CreateMemberInput, opts ...request.Option) (*managedblockchain.CreateMemberOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "CreateMember",
		Input:   input,
		Output:  (*managedblockchain.CreateMemberOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.CreateMemberWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.CreateMemberOutput), req.Error
}

func (c *Client) CreateNetworkWithContext(ctx context.Context, input *managedblockchain.CreateNetworkInput, opts ...request.Option) (*managedblockchain.CreateNetworkOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "CreateNetwork",
		Input:   input,
		Output:  (*managedblockchain.CreateNetworkOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.CreateNetworkWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.CreateNetworkOutput), req.Error
}

func (c *Client) CreateNodeWithContext(ctx context.Context, input *managedblockchain.CreateNodeInput, opts ...request.Option) (*managedblockchain.CreateNodeOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "CreateNode",
		Input:   input,
		Output:  (*managedblockchain.CreateNodeOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.CreateNodeWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.CreateNodeOutput), req.Error
}

func (c *Client) CreateProposalWithContext(ctx context.Context, input *managedblockchain.CreateProposalInput, opts ...request.Option) (*managedblockchain.CreateProposalOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "CreateProposal",
		Input:   input,
		Output:  (*managedblockchain.CreateProposalOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.CreateProposalWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.CreateProposalOutput), req.Error
}

func (c *Client) DeleteAccessorWithContext(ctx context.Context, input *managedblockchain.DeleteAccessorInput, opts ...request.Option) (*managedblockchain.DeleteAccessorOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "DeleteAccessor",
		Input:   input,
		Output:  (*managedblockchain.DeleteAccessorOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.DeleteAccessorWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.DeleteAccessorOutput), req.Error
}

func (c *Client) DeleteMemberWithContext(ctx context.Context, input *managedblockchain.DeleteMemberInput, opts ...request.Option) (*managedblockchain.DeleteMemberOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "DeleteMember",
		Input:   input,
		Output:  (*managedblockchain.DeleteMemberOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.DeleteMemberWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.DeleteMemberOutput), req.Error
}

func (c *Client) DeleteNodeWithContext(ctx context.Context, input *managedblockchain.DeleteNodeInput, opts ...request.Option) (*managedblockchain.DeleteNodeOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "DeleteNode",
		Input:   input,
		Output:  (*managedblockchain.DeleteNodeOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.DeleteNodeWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.DeleteNodeOutput), req.Error
}

func (c *Client) GetAccessorWithContext(ctx context.Context, input *managedblockchain.GetAccessorInput, opts ...request.Option) (*managedblockchain.GetAccessorOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "GetAccessor",
		Input:   input,
		Output:  (*managedblockchain.GetAccessorOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.GetAccessorWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.GetAccessorOutput), req.Error
}

func (c *Client) GetMemberWithContext(ctx context.Context, input *managedblockchain.GetMemberInput, opts ...request.Option) (*managedblockchain.GetMemberOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "GetMember",
		Input:   input,
		Output:  (*managedblockchain.GetMemberOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.GetMemberWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.GetMemberOutput), req.Error
}

func (c *Client) GetNetworkWithContext(ctx context.Context, input *managedblockchain.GetNetworkInput, opts ...request.Option) (*managedblockchain.GetNetworkOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "GetNetwork",
		Input:   input,
		Output:  (*managedblockchain.GetNetworkOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.GetNetworkWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.GetNetworkOutput), req.Error
}

func (c *Client) GetNodeWithContext(ctx context.Context, input *managedblockchain.GetNodeInput, opts ...request.Option) (*managedblockchain.GetNodeOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "GetNode",
		Input:   input,
		Output:  (*managedblockchain.GetNodeOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.GetNodeWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.GetNodeOutput), req.Error
}

func (c *Client) GetProposalWithContext(ctx context.Context, input *managedblockchain.GetProposalInput, opts ...request.Option) (*managedblockchain.GetProposalOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "GetProposal",
		Input:   input,
		Output:  (*managedblockchain.GetProposalOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.GetProposalWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.GetProposalOutput), req.Error
}

func (c *Client) ListAccessorsWithContext(ctx context.Context, input *managedblockchain.ListAccessorsInput, opts ...request.Option) (*managedblockchain.ListAccessorsOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListAccessors",
		Input:   input,
		Output:  (*managedblockchain.ListAccessorsOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListAccessorsWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListAccessorsOutput), req.Error
}

func (c *Client) ListAccessorsPagesWithContext(ctx context.Context, input *managedblockchain.ListAccessorsInput, cb func(*managedblockchain.ListAccessorsOutput, bool) bool, opts ...request.Option) error {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListAccessors",
		Input:   input,
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Error = c.ManagedBlockchainAPI.ListAccessorsPagesWithContext(ctx, input, cb, opts...)
	})

	return req.Error
}

func (c *Client) ListInvitationsWithContext(ctx context.Context, input *managedblockchain.ListInvitationsInput, opts ...request.Option) (*managedblockchain.ListInvitationsOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListInvitations",
		Input:   input,
		Output:  (*managedblockchain.ListInvitationsOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListInvitationsWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListInvitationsOutput), req.Error
}

func (c *Client) ListInvitationsPagesWithContext(ctx context.Context, input *managedblockchain.ListInvitationsInput, cb func(*managedblockchain.ListInvitationsOutput, bool) bool, opts ...request.Option) error {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListInvitations",
		Input:   input,
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Error = c.ManagedBlockchainAPI.ListInvitationsPagesWithContext(ctx, input, cb, opts...)
	})

	return req.Error
}

func (c *Client) ListMembersWithContext(ctx context.Context, input *managedblockchain.ListMembersInput, opts ...request.Option) (*managedblockchain.ListMembersOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListMembers",
		Input:   input,
		Output:  (*managedblockchain.ListMembersOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListMembersWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListMembersOutput), req.Error
}

func (c *Client) ListMembersPagesWithContext(ctx context.Context, input *managedblockchain.ListMembersInput, cb func(*managedblockchain.ListMembersOutput, bool) bool, opts ...request.Option) error {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListMembers",
		Input:   input,
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Error = c.ManagedBlockchainAPI.ListMembersPagesWithContext(ctx, input, cb, opts...)
	})

	return req.Error
}

func (c *Client) ListNetworksWithContext(ctx context.Context, input *managedblockchain.ListNetworksInput, opts ...request.Option) (*managedblockchain.ListNetworksOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListNetworks",
		Input:   input,
		Output:  (*managedblockchain.ListNetworksOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListNetworksWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListNetworksOutput), req.Error
}

func (c *Client) ListNetworksPagesWithContext(ctx context.Context, input *managedblockchain.ListNetworksInput, cb func(*managedblockchain.ListNetworksOutput, bool) bool, opts ...request.Option) error {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListNetworks",
		Input:   input,
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Error = c.ManagedBlockchainAPI.ListNetworksPagesWithContext(ctx, input, cb, opts...)
	})

	return req.Error
}

func (c *Client) ListNodesWithContext(ctx context.Context, input *managedblockchain.ListNodesInput, opts ...request.Option) (*managedblockchain.ListNodesOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListNodes",
		Input:   input,
		Output:  (*managedblockchain.ListNodesOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListNodesWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListNodesOutput), req.Error
}

func (c *Client) ListNodesPagesWithContext(ctx context.Context, input *managedblockchain.ListNodesInput, cb func(*managedblockchain.ListNodesOutput, bool) bool, opts ...request.Option) error {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListNodes",
		Input:   input,
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Error = c.ManagedBlockchainAPI.ListNodesPagesWithContext(ctx, input, cb, opts...)
	})

	return req.Error
}

func (c *Client) ListProposalVotesWithContext(ctx context.Context, input *managedblockchain.ListProposalVotesInput, opts ...request.Option) (*managedblockchain.ListProposalVotesOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListProposalVotes",
		Input:   input,
		Output:  (*managedblockchain.ListProposalVotesOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListProposalVotesWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListProposalVotesOutput), req.Error
}

func (c *Client) ListProposalVotesPagesWithContext(ctx context.Context, input *managedblockchain.ListProposalVotesInput, cb func(*managedblockchain.ListProposalVotesOutput, bool) bool, opts ...request.Option) error {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListProposalVotes",
		Input:   input,
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Error = c.ManagedBlockchainAPI.ListProposalVotesPagesWithContext(ctx, input, cb, opts...)
	})

	return req.Error
}

func (c *Client) ListProposalsWithContext(ctx context.Context, input *managedblockchain.ListProposalsInput, opts ...request.Option) (*managedblockchain.ListProposalsOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListProposals",
		Input:   input,
		Output:  (*managedblockchain.ListProposalsOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListProposalsWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListProposalsOutput), req.Error
}

func (c *Client) ListProposalsPagesWithContext(ctx context.Context, input *managedblockchain.ListProposalsInput, cb func(*managedblockchain.ListProposalsOutput, bool) bool, opts ...request.Option) error {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListProposals",
		Input:   input,
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Error = c.ManagedBlockchainAPI.ListProposalsPagesWithContext(ctx, input, cb, opts...)
	})

	return req.Error
}

func (c *Client) ListTagsForResourceWithContext(ctx context.Context, input *managedblockchain.ListTagsForResourceInput, opts ...request.Option) (*managedblockchain.ListTagsForResourceOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "ListTagsForResource",
		Input:   input,
		Output:  (*managedblockchain.ListTagsForResourceOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.ListTagsForResourceWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.ListTagsForResourceOutput), req.Error
}

func (c *Client) RejectInvitationWithContext(ctx context.Context, input *managedblockchain.RejectInvitationInput, opts ...request.Option) (*managedblockchain.RejectInvitationOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "RejectInvitation",
		Input:   input,
		Output:  (*managedblockchain.RejectInvitationOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.RejectInvitationWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.RejectInvitationOutput), req.Error
}

func (c *Client) TagResourceWithContext(ctx context.Context, input *managedblockchain.TagResourceInput, opts ...request.Option) (*managedblockchain.TagResourceOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "TagResource",
		Input:   input,
		Output:  (*managedblockchain.TagResourceOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.TagResourceWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.TagResourceOutput), req.Error
}

func (c *Client) UntagResourceWithContext(ctx context.Context, input *managedblockchain.UntagResourceInput, opts ...request.Option) (*managedblockchain.UntagResourceOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "UntagResource",
		Input:   input,
		Output:  (*managedblockchain.UntagResourceOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.UntagResourceWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.UntagResourceOutput), req.Error
}

func (c *Client) UpdateMemberWithContext(ctx context.Context, input *managedblockchain.UpdateMemberInput, opts ...request.Option) (*managedblockchain.UpdateMemberOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "UpdateMember",
		Input:   input,
		Output:  (*managedblockchain.UpdateMemberOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.UpdateMemberWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.UpdateMemberOutput), req.Error
}

func (c *Client) UpdateNodeWithContext(ctx context.Context, input *managedblockchain.UpdateNodeInput, opts ...request.Option) (*managedblockchain.UpdateNodeOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "UpdateNode",
		Input:   input,
		Output:  (*managedblockchain.UpdateNodeOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.UpdateNodeWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.UpdateNodeOutput), req.Error
}

func (c *Client) VoteOnProposalWithContext(ctx context.Context, input *managedblockchain.VoteOnProposalInput, opts ...request.Option) (*managedblockchain.VoteOnProposalOutput, error) {
	req := &awsctx.AwsRequest{
		Service: "managedblockchain",
		Action:  "VoteOnProposal",
		Input:   input,
		Output:  (*managedblockchain.VoteOnProposalOutput)(nil),
		Error:   nil,
	}

	ctxer := c.Contexter
	if ctxer == nil {
		ctxer = awsctx.NoopContexter
	}

	ctxer.WrapContext(ctx, req, func(ctx context.Context) {
		req.Output, req.Error = c.ManagedBlockchainAPI.VoteOnProposalWithContext(ctx, input, opts...)
	})

	return req.Output.(*managedblockchain.VoteOnProposalOutput), req.Error
}
